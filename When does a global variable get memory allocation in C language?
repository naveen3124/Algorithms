There are two types of global variables, initialized ones and uninitialized ones.

So when your compiler compiles the code, it creates two separate blocks of memory, data segment and bss. Data segment contains initialized globals and bss contains uninitialized globals. For initialized globals, the value is right there embedded in data segment.

When linker comes and combines all the object files/libraries etc, it combines all the data segments into a one big data segment (along with the values they are initialized with) and for bss, it just mentions the size of bss as there is no data to initialize variables with. This information goes into the binary that gets generated as a result of compilation process.

When loader loads your program, it reads data segment from binary and copies it into RAM. For bss, it reads the size information, creates a big enough chunk in RAM and sets this memory area to 0.

So technically, memory for globals gets allocated (or rather reserved) at compile time and it comes to life (ie actually gets an area in RAM) when your binary gets loaded into RAM at run-time before any code is even run.

This is a simplistic view and there are few special cases like some global variable getting initialized by a call to some function.

For example if you have a global variable as

    int count = printf("hello");

code printf("hello"); gets executed and return value from printf is loaded into variable count. But the part about allocation still holds true ie memory for count gets reserved at compiled time and count gets an address at link time.

From quora user 
